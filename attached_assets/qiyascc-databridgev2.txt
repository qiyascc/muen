Directory structure:
└── trendyol_app/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── models.py
    ├── scheduler.py
    ├── serializers.py
    ├── services.py
    ├── signals.py
    ├── tasks.py
    ├── tests.py
    ├── urls.py
    ├── views.py
    ├── management/
    │   ├── __init__.py
    │   └── commands/
    │       ├── __init__.py
    │       └── check_batches.py
    └── migrations/
        ├── 0001_initial.py
        ├── 0002_rename_product_trendyolproduct.py
        ├── 0003_remove_trendyolproduct_cargo_company_id_and_more.py
        ├── 0004_trendyolapiconfig_delete_apiconfig_and_more.py
        ├── 0005_remove_trendyolproduct_cargo_company_id_and_more.py
        └── __init__.py

================================================
FILE: databridge/markets/trendyol_app/__init__.py
================================================



================================================
FILE: databridge/markets/trendyol_app/admin.py
================================================
from django.contrib import admin
from django.utils.html import format_html
from .models import TrendyolAPIConfig, TrendyolProduct

@admin.register(TrendyolAPIConfig)
class TrendyolAPIConfigAdmin(admin.ModelAdmin):
    list_display = ('seller_id', 'is_active', 'created_at', 'updated_at')
    search_fields = ('seller_id',)
    list_filter = ('is_active',)


@admin.register(TrendyolProduct)
class TrendyolProductAdmin(admin.ModelAdmin):
    list_display = ('title', 'barcode', 'brand_name', 'category_name', 
                    'quantity', 'price', 'sale_price', 'batch_id', 
                    'batch_status', 'last_check_time')
    list_filter = ('batch_status', 'brand_name')
    search_fields = ('title', 'barcode', 'product_main_id', 'batch_id')
    readonly_fields = ('batch_id', 'batch_status', 'status_message', 'last_check_time', 'display_image')
    fieldsets = (
        (None, {
            'fields': ('barcode', 'title', 'product_main_id', 'brand_name', 'category_name')
        }),
        ('Stok ve Fiyat Bilgileri', {
            'fields': ('quantity', 'stock_code', 'price', 'sale_price', 'vat_rate', 'currency_type')
        }),
        ('Ürün Detayları', {
            'fields': ('description', 'image_url', 'display_image',)
        }),
        ('Trendyol Entegrasyon Durumu', {
            'fields': ('batch_id', 'batch_status', 'status_message', 'last_check_time'),
            'classes': ('collapse',)
        }),
    )
    
    def display_image(self, obj):
        if obj.image_url:
            return format_html('<img src="{}" height="150" />', obj.image_url)
        return "Resim yok"
    display_image.short_description = "Ürün Resmi"
    
    actions = ['check_batch_status']
    
    def check_batch_status(self, request, queryset):
        from .services import check_product_batch_status
        updated = 0
        for product in queryset:
            if product.batch_id and product.batch_status != 'completed':
                check_product_batch_status(product)
                updated += 1
        
        self.message_user(request, f"{updated} ürünün batch durumu güncellendi.")
    check_batch_status.short_description = "Seçili ürünlerin batch durumlarını kontrol et"


================================================
FILE: databridge/markets/trendyol_app/apps.py
================================================
from django.apps import AppConfig


class TrendyolAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'markets.trendyol_app'
    verbose_name = 'Trendyol API Entegrasyonu'
    
    def ready(self):
        from . import signals
        from .scheduler import start_scheduler


================================================
FILE: databridge/markets/trendyol_app/models.py
================================================
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils import timezone

class TrendyolAPIConfig(models.Model):
    seller_id = models.CharField(max_length=100, verbose_name=_("Satıcı ID"))
    api_key = models.CharField(max_length=255, verbose_name=_("API Key"))
    base_url = models.CharField(
        max_length=255, 
        default="https://apigw.trendyol.com/integration/",
        verbose_name=_("API Base URL")
    )
    is_active = models.BooleanField(default=True, verbose_name=_("Aktif Mi?"))
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = _("Trendyol API Konfigürasyonu")
        verbose_name_plural = _("Trendyol API Konfigürasyonları")
    
    def __str__(self):
        return f"Trendyol API Config: {self.seller_id}"


class TrendyolProduct(models.Model):
    BATCH_STATUS_CHOICES = [
        ('pending', _('Beklemede')),
        ('processing', _('İşleniyor')),
        ('completed', _('Tamamlandı')),
        ('failed', _('Başarısız')),
    ]
    
    barcode = models.CharField(max_length=100, unique=True, verbose_name=_("Barkod"))
    title = models.CharField(max_length=255, verbose_name=_("Başlık"))
    product_main_id = models.CharField(max_length=100, unique=True, verbose_name=_("Ürün Ana ID"))
    brand_name = models.CharField(max_length=255, verbose_name=_("Marka Adı"))
    category_name = models.CharField(max_length=255, verbose_name=_("Kategori Adı"))
    quantity = models.PositiveIntegerField(default=0, verbose_name=_("Stok Miktarı"))
    stock_code = models.CharField(max_length=100, verbose_name=_("Stok Kodu"))
    price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=_("Liste Fiyatı"))
    sale_price = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=_("Satış Fiyatı"))
    description = models.TextField(verbose_name=_("Açıklama"))
    image_url = models.URLField(verbose_name=_("Resim URL"))
    vat_rate = models.PositiveSmallIntegerField(default=10, verbose_name=_("KDV Oranı"))
    currency_type = models.CharField(max_length=10, default="TRY", verbose_name=_("Para Birimi"))
    
    batch_id = models.CharField(max_length=100, null=True, blank=True, verbose_name=_("Batch ID"))
    batch_status = models.CharField(
        max_length=20,
        choices=BATCH_STATUS_CHOICES,
        default='pending',
        verbose_name=_("Batch Durumu")
    )
    status_message = models.TextField(null=True, blank=True, verbose_name=_("Durum Mesajı"))
    last_check_time = models.DateTimeField(null=True, blank=True, verbose_name=_("Son Kontrol Zamanı"))
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = _("Trendyol Ürünü")
        verbose_name_plural = _("Trendyol Ürünleri")
    
    def __str__(self):
        return f"{self.title} - {self.barcode}"
    
    def set_batch_status(self, status, message=None):
        self.batch_status = status
        if message:
            self.status_message = message
        self.last_check_time = timezone.now()
        self.save(update_fields=['batch_status', 'status_message', 'last_check_time'])
    
    def needs_status_check(self):
        if self.batch_status in ['completed', 'failed']:
            return False
        
        if not self.last_check_time:
            return True
        
        # 2 dakikada bir kontrol et
        return (timezone.now() - self.last_check_time).total_seconds() >= 120


================================================
FILE: databridge/markets/trendyol_app/scheduler.py
================================================
from apscheduler.schedulers.background import BackgroundScheduler
from django_apscheduler.jobstores import DjangoJobStore
from django.utils import timezone
import logging
from .services import check_pending_products

logger = logging.getLogger(__name__)

def start_scheduler():
    try:
        scheduler = BackgroundScheduler()
        scheduler.add_jobstore(DjangoJobStore(), "default")
        
        # 2 dakikada bir bekleyen ürünlerin durumunu kontrol et
        scheduler.add_job(
            check_pending_products,
            'interval',
            minutes=2,
            id='check_pending_products',
            replace_existing=True
        )
        
        logger.info("Trendyol batch status check scheduler started")
        scheduler.start()
    except Exception as e:
        logger.error(f"Could not start scheduler: {e}")


================================================
FILE: databridge/markets/trendyol_app/serializers.py
================================================
from rest_framework import serializers
from .models import TrendyolProduct

class TrendyolProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = TrendyolProduct
        fields = '__all__'
        read_only_fields = ('batch_id', 'batch_status', 'status_message', 'last_check_time')


================================================
FILE: databridge/markets/trendyol_app/services.py
================================================
import requests
import json
import uuid
import logging
from urllib.parse import quote
from django.utils import timezone
from sentence_transformers import SentenceTransformer, util
from collections import defaultdict
from PyMultiDictionary import MultiDictionary
from functools import lru_cache
import time

from .models import TrendyolAPIConfig, TrendyolProduct

# Configure logging
logger = logging.getLogger(__name__)

# Constants
DEFAULT_TIMEOUT = 15
MAX_RETRIES = 3
RETRY_DELAY = 1

class TrendyolAPI:
    """Base class for Trendyol API operations with retry mechanism"""
    
    def __init__(self, config: TrendyolAPIConfig):
        self.config = config
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"Basic {self.config.api_key}",
            "User-Agent": f"{self.config.seller_id} - SelfIntegration",
            "Content-Type": "application/json"
        })
    
    def _make_request(self, method, endpoint, **kwargs):
        """Generic request method with retry logic"""
        url = f"{self.config.base_url.rstrip('/')}/{endpoint.lstrip('/')}"
        kwargs.setdefault('timeout', DEFAULT_TIMEOUT)
        
        for attempt in range(MAX_RETRIES):
            try:
                response = self.session.request(method, url, **kwargs)
                response.raise_for_status()
                return response.json()
            except requests.exceptions.RequestException as e:
                if attempt == MAX_RETRIES - 1:
                    logger.error(f"API request failed after {MAX_RETRIES} attempts: {str(e)}")
                    raise
                logger.warning(f"Attempt {attempt + 1} failed, retrying...")
                time.sleep(RETRY_DELAY * (attempt + 1))
    
    def get(self, endpoint, params=None):
        return self._make_request('GET', endpoint, params=params)
    
    def post(self, endpoint, data):
        return self._make_request('POST', endpoint, json=data)


class TrendyolCategoryFinder:
    """Handles category discovery and attribute management"""
    
    def __init__(self, api_client: TrendyolAPI):
        self.api = api_client
        self.model = SentenceTransformer('emrecan/bert-base-turkish-cased-mean-nli-stsb-tr')
        self.dictionary = MultiDictionary()
        self._category_cache = None
        self._attribute_cache = {}
    
    @property
    def category_cache(self):
        if self._category_cache is None:
            self._category_cache = self._fetch_all_categories()
        return self._category_cache
    
    def _fetch_all_categories(self):
        """Fetch all categories from Trendyol API"""
        try:
            data = self.api.get("product/product-categories")
            return data.get('categories', [])
        except Exception as e:
            logger.error(f"Failed to fetch categories: {str(e)}")
            raise Exception("Failed to load categories. Please check your API credentials and try again.")
    
    @lru_cache(maxsize=128)
    def get_category_attributes(self, category_id):
        """Get attributes for a specific category with caching"""
        try:
            data = self.api.get(f"product/product-categories/{category_id}/attributes")
            return data
        except Exception as e:
            logger.error(f"Failed to fetch attributes for category {category_id}: {str(e)}")
            raise Exception(f"Failed to load attributes for category {category_id}")
    
    def find_best_category(self, search_term):
        """Find the most relevant category for a given search term"""
        try:
            categories = self.category_cache
            if not categories:
                raise ValueError("Empty category list received from API")
            
            all_matches = self._find_all_possible_matches(search_term, categories)
            
            if exact_match := self._find_exact_match(search_term, all_matches):
                return exact_match
            
            if all_matches:
                return self._select_best_match(search_term, all_matches)['id']
            
            leaf_categories = self._get_all_leaf_categories(categories)
            if leaf_categories:
                return self._select_best_match(search_term, leaf_categories)['id']
            
            suggestions = self._get_category_suggestions(search_term, categories)
            raise ValueError(f"No exact match found. Closest categories:\n{suggestions}")
            
        except Exception as e:
            logger.error(f"Category search failed for '{search_term}': {str(e)}")
            raise
    
    def _find_all_possible_matches(self, search_term, categories):
        """Find all possible matches including synonyms"""
        search_terms = {search_term.lower()}
        
        try:
            synonyms = self.dictionary.synonym('tr', search_term.lower())
            search_terms.update(synonyms[:5])
        except Exception as e:
            logger.debug(f"Couldn't fetch synonyms: {str(e)}")
        
        matches = []
        for term in search_terms:
            matches.extend(self._find_matches_for_term(term, categories))
        
        # Deduplicate while preserving order
        seen_ids = set()
        return [m for m in matches if not (m['id'] in seen_ids or seen_ids.add(m['id']))]
    
    def _find_matches_for_term(self, term, categories):
        """Recursively find matches in category tree"""
        matches = []
        term_lower = term.lower()
        
        for cat in categories:
            cat_name_lower = cat['name'].lower()
            
            if term_lower == cat_name_lower or term_lower in cat_name_lower:
                if not cat.get('subCategories'):
                    matches.append(cat)
            
            if cat.get('subCategories'):
                matches.extend(self._find_matches_for_term(term, cat['subCategories']))
        
        return matches
    
    def _find_exact_match(self, search_term, matches):
        """Check for exact name matches"""
        search_term_lower = search_term.lower()
        for match in matches:
            if search_term_lower == match['name'].lower():
                return match['id']
        return None
    
    def _select_best_match(self, search_term, candidates):
        """Select best match using semantic similarity"""
        search_embedding = self.model.encode(search_term, convert_to_tensor=True)
        
        for candidate in candidates:
            candidate_embedding = self.model.encode(candidate['name'], convert_to_tensor=True)
            candidate['similarity'] = util.cos_sim(search_embedding, candidate_embedding).item()
        
        candidates_sorted = sorted(candidates, key=lambda x: x['similarity'], reverse=True)
        
        logger.info(f"Top 3 matches for '{search_term}':")
        for i, candidate in enumerate(candidates_sorted[:3], 1):
            logger.info(f"{i}. {candidate['name']} (Similarity: {candidate['similarity']:.2f})")
        
        return candidates_sorted[0]
    
    def _get_all_leaf_categories(self, categories):
        """Get all leaf categories (categories without children)"""
        leaf_categories = []
        self._collect_leaf_categories(categories, leaf_categories)
        return leaf_categories
    
    def _collect_leaf_categories(self, categories, result):
        """Recursively collect leaf categories"""
        for cat in categories:
            if not cat.get('subCategories'):
                result.append(cat)
            else:
                self._collect_leaf_categories(cat['subCategories'], result)
    
    def _get_category_suggestions(self, search_term, categories, top_n=3):
        """Generate user-friendly suggestions"""
        leaf_categories = self._get_all_leaf_categories(categories)
        
        search_embedding = self.model.encode(search_term, convert_to_tensor=True)
        for cat in leaf_categories:
            cat_embedding = self.model.encode(cat['name'], convert_to_tensor=True)
            cat['similarity'] = util.cos_sim(search_embedding, cat_embedding).item()
        
        sorted_cats = sorted(leaf_categories, key=lambda x: x['similarity'], reverse=True)
        
        suggestions = []
        for i, cat in enumerate(sorted_cats[:top_n], 1):
            suggestions.append(f"{i}. {cat['name']} (Similarity: {cat['similarity']:.2f}, ID: {cat['id']})")
        
        return "\n".join(suggestions)


class TrendyolProductManager:
    """Handles product creation and management"""
    
    def __init__(self, api_client: TrendyolAPI):
        self.api = api_client
        self.category_finder = TrendyolCategoryFinder(api_client)
    
    def get_brand_id(self, brand_name):
        """Find brand ID by name"""
        encoded_name = quote(brand_name)
        try:
            brands = self.api.get(f"product/brands/by-name?name={encoded_name}")
            if isinstance(brands, list) and brands:
                return brands[0]['id']
            raise ValueError(f"Brand not found: {brand_name}")
        except Exception as e:
            logger.error(f"Brand search failed for '{brand_name}': {str(e)}")
            raise
    
    def create_product(self, product_data):
        """Create a new product on Trendyol"""
        try:
            category_id = self.category_finder.find_best_category(product_data.category_name)
            brand_id = self.get_brand_id(product_data.brand_name)
            attributes = self._get_sample_attributes(category_id)
            
            payload = self._build_product_payload(product_data, category_id, brand_id, attributes)
            
            logger.info("Submitting product creation request...")
            response = self.api.post(f"product/sellers/{self.api.config.seller_id}/products", payload)
            
            return response.get('batchRequestId')
        except Exception as e:
            logger.error(f"Product creation failed: {str(e)}")
            raise
    
    def check_batch_status(self, batch_id):
        """Check the status of a batch operation"""
        try:
            return self.api.get(f"product/sellers/{self.api.config.seller_id}/products/batch-requests/{batch_id}")
        except Exception as e:
            logger.error(f"Failed to check batch status: {str(e)}")
            raise
    
    def _build_product_payload(self, product, category_id, brand_id, attributes):
        from config.utils import apply_price_configuration, apply_stock_configuration
        """Construct the complete product payload"""
        return {
            "items": [{
                "barcode": product.barcode,
                "title": product.title,
                "productMainId": product.product_main_id,
                "brandId": brand_id,
                "categoryId": category_id,
                "quantity": apply_stock_configuration(product.quantity),
                "stockCode": product.stock_code,
                "description": product.description,
                "currencyType": product.currency_type,
                "listPrice": float(apply_price_configuration(product.price)) + 10,
                "salePrice": float(apply_price_configuration(product.price)),
                "vatRate": product.vat_rate,
                "images": [{"url": product.image_url}],
                "attributes": attributes
            }]
        }
    
    def _get_sample_attributes(self, category_id):
        """Generate sample attributes for a category"""
        attributes = []
        category_attrs = self.category_finder.get_category_attributes(category_id)
        
        for attr in category_attrs.get('categoryAttributes', []):
            # Skip attributes with empty attributeValues array when custom values are not allowed
            if not attr.get('attributeValues') and not attr.get('allowCustom'):
                continue
                
            attribute = {
                "attributeId": attr['attribute']['id'],
                "attributeName": attr['attribute']['name']
            }
            
            if attr.get('attributeValues') and len(attr['attributeValues']) > 0:
                if not attr['allowCustom']:
                    attribute["attributeValueId"] = attr['attributeValues'][0]['id']
                    attribute["attributeValue"] = attr['attributeValues'][0]['name']
                else:
                    attribute["customAttributeValue"] = f"Sample {attr['attribute']['name']}"
            elif attr.get('allowCustom'):
                attribute["customAttributeValue"] = f"Sample {attr['attribute']['name']}"
            else:
                continue
            
            attributes.append(attribute)
        
        return attributes


def get_active_api_config():
    try:
        return TrendyolAPIConfig.objects.filter(is_active=True).first()
    except:
        return None


def create_trendyol_product(product):
    config = get_active_api_config()
    if not config:
        logger.error("No active Trendyol API config found")
        product.set_batch_status('failed', 'No active Trendyol API config found')
        return
    
    try:
        api = TrendyolAPI(config)
        product_manager = TrendyolProductManager(api)
        
        batch_id = product_manager.create_product(product)
        
        product.batch_id = batch_id
        product.batch_status = 'processing'
        product.status_message = 'Product creation initiated'
        product.last_check_time = timezone.now()
        product.save()
        
        return batch_id
        
    except Exception as e:
        logger.error(f"Failed to create product on Trendyol: {str(e)}")
        product.set_batch_status('failed', f"Error: {str(e)}")
        return None


def check_product_batch_status(product):
    if not product.batch_id:
        return
    
    config = get_active_api_config()
    if not config:
        logger.error("No active Trendyol API config found")
        return
    
    try:
        api = TrendyolAPI(config)
        product_manager = TrendyolProductManager(api)
        
        status_data = product_manager.check_batch_status(product.batch_id)
        
        items = status_data.get('items', [])
        if not items:
            product.set_batch_status('processing', 'Waiting for processing')
            return
        
        item = items[0]
        status = item.get('status')
        
        if status == 'SUCCESS':
            product.set_batch_status('completed', 'Product created successfully')
        elif status == 'ERROR':
            product.set_batch_status('failed', f"Error: {item.get('failureReasons', 'Unknown error')}")
        else:
            product.set_batch_status('processing', f"Status: {status}")
        
    except Exception as e:
        logger.error(f"Failed to check batch status: {str(e)}")
        product.last_check_time = timezone.now()
        product.save(update_fields=['last_check_time'])


def check_pending_products():
    products = TrendyolProduct.objects.filter(
        batch_id__isnull=False,
        batch_status__in=['pending', 'processing']
    )
    
    for product in products:
        if product.needs_status_check():
            logger.info(f"Checking status for product {product.id}: {product.title}")
            check_product_batch_status(product)


================================================
FILE: databridge/markets/trendyol_app/signals.py
================================================
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import TrendyolProduct
from .services import create_trendyol_product

@receiver(post_save, sender=TrendyolProduct)
def product_post_save(sender, instance, created, **kwargs):
    if created and not instance.batch_id:
        # Yeni ürün oluşturulduğunda Trendyol'a gönder
        create_trendyol_product(instance)


================================================
FILE: databridge/markets/trendyol_app/tasks.py
================================================
import logging
from django.db import transaction
from django.utils import timezone
from datetime import timedelta
from .models import BatchRequest, APIConfig
from .services.trendyol_api import TrendyolAPI, TrendyolProductManager

logger = logging.getLogger(__name__)

def check_batch_status(batch_request_id):
    """Check the status of a batch request"""
    with transaction.atomic():
        batch_request = BatchRequest.objects.select_for_update().get(id=batch_request_id)
        
        # Skip completed batches
        if batch_request.status in ['COMPLETED', 'FAILED']:
            logger.info(f"Batch {batch_request.batch_id} already in final state: {batch_request.status}")
            return
        
        # Get API config
        api_config = APIConfig.objects.filter(is_default=True).first()
        if not api_config:
            logger.error("No default API configuration found")
            batch_request.error_message = "No default API configuration found"
            batch_request.save()
            return
            
        try:
            # Initialize API client
            api_client = TrendyolAPI(
                api_key=api_config.api_key,
                seller_id=api_config.seller_id,
                base_url=api_config.base_url
            )
            product_manager = TrendyolProductManager(api_client)
            
            # Check status from API
            status_data = product_manager.check_batch_status(batch_request.batch_id)
            
            # Update status
            if status_data:
                api_status = status_data.get('status', '').upper()
                if api_status in ['PROCESSING', 'COMPLETED', 'FAILED']:
                    batch_request.status = api_status
                
                # Store error message if any
                if api_status == 'FAILED' and 'failureReasons' in status_data:
                    error_details = []
                    for reason in status_data['failureReasons']:
                        error_details.append(f"{reason.get('code', '')}: {reason.get('message', '')}")
                    
                    batch_request.error_message = "\n".join(error_details)
            
            batch_request.last_checked = timezone.now()
            batch_request.save()
            
            logger.info(f"Batch {batch_request.batch_id} status updated to: {batch_request.status}")
            
            return batch_request.status
            
        except Exception as e:
            logger.error(f"Error checking batch status: {str(e)}")
            batch_request.error_message = f"Error: {str(e)}"
            batch_request.last_checked = timezone.now()
            batch_request.save()
            raise

def schedule_batch_status_checks():
    """Schedule status checks for all non-completed batch requests"""
    # Find all batches that need checking (not in final state and not checked in last 2 minutes)
    cutoff_time = timezone.now() - timedelta(minutes=2)
    pending_batches = BatchRequest.objects.filter(
        status__in=['CREATED', 'PROCESSING'],
        last_checked__lt=cutoff_time
    )
    
    count = 0
    for batch in pending_batches:
        try:
            check_batch_status(batch.id)
            count += 1
        except Exception as e:
            logger.error(f"Failed to check batch {batch.batch_id}: {str(e)}")
    
    logger.info(f"Scheduled checks completed for {count} batches")
    return count


================================================
FILE: databridge/markets/trendyol_app/tests.py
================================================
from django.test import TestCase

# Create your tests here.



================================================
FILE: databridge/markets/trendyol_app/urls.py
================================================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

app_name = 'trendyol_app'

router = DefaultRouter()
router.register(r'products', views.TrendyolProductViewSet)

urlpatterns = [
    path('', include(router.urls)),
]


================================================
FILE: databridge/markets/trendyol_app/views.py
================================================
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from .models import TrendyolProduct
from .serializers import TrendyolProductSerializer
from .services import check_product_batch_status

class TrendyolProductViewSet(viewsets.ModelViewSet):
    queryset = TrendyolProduct.objects.all()
    serializer_class = TrendyolProductSerializer
    
    @action(detail=True, methods=['post'])
    def check_status(self, request, pk=None):
        product = self.get_object()
        
        if not product.batch_id:
            return Response(
                {'error': 'Bu ürün henüz Trendyol\'a gönderilmemiş'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        check_product_batch_status(product)
        return Response({
            'batch_id': product.batch_id,
            'batch_status': product.batch_status,
            'status_message': product.status_message,
            'last_check_time': product.last_check_time
        })


================================================
FILE: databridge/markets/trendyol_app/management/__init__.py
================================================



================================================
FILE: databridge/markets/trendyol_app/management/commands/__init__.py
================================================



================================================
FILE: databridge/markets/trendyol_app/management/commands/check_batches.py
================================================
from django.core.management.base import BaseCommand
from markets.trendyol_app.tasks import schedule_batch_status_checks

class Command(BaseCommand):
    help = 'Checks status of all pending Trendyol batch requests'

    def handle(self, *args, **options):
        count = schedule_batch_status_checks()
        self.stdout.write(
            self.style.SUCCESS(f'Successfully checked {count} batch requests')
        )


================================================
FILE: databridge/markets/trendyol_app/migrations/0001_initial.py
================================================
# Generated by Django 5.1.8 on 2025-04-04 10:11

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="APIConfig",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=100)),
                ("api_key", models.CharField(max_length=255)),
                ("seller_id", models.CharField(max_length=50)),
                (
                    "base_url",
                    models.URLField(default="https://apigw.trendyol.com/integration/"),
                ),
                ("is_default", models.BooleanField(default=False)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
            ],
            options={
                "verbose_name": "API Configuration",
                "verbose_name_plural": "API Configurations",
            },
        ),
        migrations.CreateModel(
            name="BatchRequest",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("batch_id", models.CharField(max_length=100, unique=True)),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("CREATED", "Created"),
                            ("PROCESSING", "Processing"),
                            ("COMPLETED", "Completed"),
                            ("FAILED", "Failed"),
                        ],
                        default="CREATED",
                        max_length=20,
                    ),
                ),
                ("last_checked", models.DateTimeField(auto_now=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("error_message", models.TextField(blank=True, null=True)),
            ],
            options={
                "verbose_name": "Batch Request",
                "verbose_name_plural": "Batch Requests",
                "ordering": ["-created_at"],
            },
        ),
        migrations.CreateModel(
            name="Product",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("barcode", models.CharField(max_length=100, unique=True)),
                ("title", models.CharField(max_length=255)),
                ("product_main_id", models.CharField(max_length=100, unique=True)),
                ("brand_name", models.CharField(max_length=100)),
                ("category_name", models.CharField(max_length=100)),
                ("quantity", models.PositiveIntegerField(default=0)),
                ("stock_code", models.CharField(max_length=100)),
                ("price", models.DecimalField(decimal_places=2, max_digits=10)),
                ("sale_price", models.DecimalField(decimal_places=2, max_digits=10)),
                ("description", models.TextField()),
                ("image_url", models.URLField()),
                ("vat_rate", models.PositiveIntegerField(default=10)),
                ("cargo_company_id", models.PositiveIntegerField(default=10)),
                ("currency_type", models.CharField(default="TRY", max_length=5)),
                ("dimensional_weight", models.PositiveIntegerField(default=1)),
                (
                    "trendyol_category_id",
                    models.PositiveIntegerField(blank=True, null=True),
                ),
                (
                    "trendyol_brand_id",
                    models.PositiveIntegerField(blank=True, null=True),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                (
                    "batch_request",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.SET_NULL,
                        related_name="products",
                        to="trendyol_app.batchrequest",
                    ),
                ),
            ],
            options={
                "verbose_name": "Product",
                "verbose_name_plural": "Products",
            },
        ),
    ]



================================================
FILE: databridge/markets/trendyol_app/migrations/0002_rename_product_trendyolproduct.py
================================================
# Generated by Django 5.1.8 on 2025-04-04 10:16

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ("trendyol_app", "0001_initial"),
    ]

    operations = [
        migrations.RenameModel(
            old_name="Product",
            new_name="TrendyolProduct",
        ),
    ]



================================================
FILE: databridge/markets/trendyol_app/migrations/0003_remove_trendyolproduct_cargo_company_id_and_more.py
================================================
# Generated by Django 5.1.8 on 2025-04-04 10:37

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ("trendyol_app", "0002_rename_product_trendyolproduct"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="trendyolproduct",
            name="cargo_company_id",
        ),
        migrations.RemoveField(
            model_name="trendyolproduct",
            name="dimensional_weight",
        ),
    ]



================================================
FILE: databridge/markets/trendyol_app/migrations/0004_trendyolapiconfig_delete_apiconfig_and_more.py
================================================
# Generated by Django 5.1.8 on 2025-04-04 11:33

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("trendyol_app", "0003_remove_trendyolproduct_cargo_company_id_and_more"),
    ]

    operations = [
        migrations.CreateModel(
            name="TrendyolAPIConfig",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "seller_id",
                    models.CharField(max_length=100, verbose_name="Satıcı ID"),
                ),
                ("api_key", models.CharField(max_length=255, verbose_name="API Key")),
                (
                    "base_url",
                    models.CharField(
                        default="https://apigw.trendyol.com/integration/",
                        max_length=255,
                        verbose_name="API Base URL",
                    ),
                ),
                (
                    "is_active",
                    models.BooleanField(default=True, verbose_name="Aktif Mi?"),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
            ],
            options={
                "verbose_name": "Trendyol API Konfigürasyonu",
                "verbose_name_plural": "Trendyol API Konfigürasyonları",
            },
        ),
        migrations.DeleteModel(
            name="APIConfig",
        ),
        migrations.RemoveField(
            model_name="trendyolproduct",
            name="batch_request",
        ),
        migrations.AlterModelOptions(
            name="trendyolproduct",
            options={
                "verbose_name": "Trendyol Ürünü",
                "verbose_name_plural": "Trendyol Ürünleri",
            },
        ),
        migrations.RemoveField(
            model_name="trendyolproduct",
            name="trendyol_brand_id",
        ),
        migrations.RemoveField(
            model_name="trendyolproduct",
            name="trendyol_category_id",
        ),
        migrations.AddField(
            model_name="trendyolproduct",
            name="batch_id",
            field=models.CharField(
                blank=True, max_length=100, null=True, verbose_name="Batch ID"
            ),
        ),
        migrations.AddField(
            model_name="trendyolproduct",
            name="batch_status",
            field=models.CharField(
                choices=[
                    ("pending", "Beklemede"),
                    ("processing", "İşleniyor"),
                    ("completed", "Tamamlandı"),
                    ("failed", "Başarısız"),
                ],
                default="pending",
                max_length=20,
                verbose_name="Batch Durumu",
            ),
        ),
        migrations.AddField(
            model_name="trendyolproduct",
            name="cargo_company_id",
            field=models.PositiveIntegerField(
                default=10, verbose_name="Kargo Firması ID"
            ),
        ),
        migrations.AddField(
            model_name="trendyolproduct",
            name="dimensional_weight",
            field=models.PositiveIntegerField(default=1, verbose_name="Desi"),
        ),
        migrations.AddField(
            model_name="trendyolproduct",
            name="last_check_time",
            field=models.DateTimeField(
                blank=True, null=True, verbose_name="Son Kontrol Zamanı"
            ),
        ),
        migrations.AddField(
            model_name="trendyolproduct",
            name="status_message",
            field=models.TextField(blank=True, null=True, verbose_name="Durum Mesajı"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="barcode",
            field=models.CharField(max_length=100, unique=True, verbose_name="Barkod"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="brand_name",
            field=models.CharField(max_length=255, verbose_name="Marka Adı"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="category_name",
            field=models.CharField(max_length=255, verbose_name="Kategori Adı"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="currency_type",
            field=models.CharField(
                default="TRY", max_length=10, verbose_name="Para Birimi"
            ),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="description",
            field=models.TextField(verbose_name="Açıklama"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="image_url",
            field=models.URLField(verbose_name="Resim URL"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="price",
            field=models.DecimalField(
                decimal_places=2, max_digits=10, verbose_name="Liste Fiyatı"
            ),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="product_main_id",
            field=models.CharField(
                max_length=100, unique=True, verbose_name="Ürün Ana ID"
            ),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="quantity",
            field=models.PositiveIntegerField(default=0, verbose_name="Stok Miktarı"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="sale_price",
            field=models.DecimalField(
                decimal_places=2, max_digits=10, verbose_name="Satış Fiyatı"
            ),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="stock_code",
            field=models.CharField(max_length=100, verbose_name="Stok Kodu"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="title",
            field=models.CharField(max_length=255, verbose_name="Başlık"),
        ),
        migrations.AlterField(
            model_name="trendyolproduct",
            name="vat_rate",
            field=models.PositiveSmallIntegerField(
                default=10, verbose_name="KDV Oranı"
            ),
        ),
        migrations.DeleteModel(
            name="BatchRequest",
        ),
    ]



================================================
FILE: databridge/markets/trendyol_app/migrations/0005_remove_trendyolproduct_cargo_company_id_and_more.py
================================================
# Generated by Django 5.1.8 on 2025-04-04 11:35

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ("trendyol_app", "0004_trendyolapiconfig_delete_apiconfig_and_more"),
    ]

    operations = [
        migrations.RemoveField(
            model_name="trendyolproduct",
            name="cargo_company_id",
        ),
        migrations.RemoveField(
            model_name="trendyolproduct",
            name="dimensional_weight",
        ),
    ]



================================================
FILE: databridge/markets/trendyol_app/migrations/__init__.py
================================================


